# 缓存实验：理解缓存存储器

15-213/18-213，2012年秋季学期  

布置日期：2012年10月2日（周二）  

截止日期：2012年10月11日晚11:59  

最晚提交时间：2012年10月14日晚11:59  

## 1 实验须知

本实验为个人项目，你必须在64位x86-64架构的机器上完成。  

**学校特定说明**：此处可补充其他须知事项（如求助方式等）。

## 2 实验概述

本实验将帮助你理解缓存存储器对C程序性能的影响，分为两部分：

- 第一部分：编写一个小型C程序（约200-300行），模拟缓存的行为；
- 第二部分：优化一个矩阵转置函数，目标是最小化缓存缺失次数。

## 3 下载实验材料

**学校特定说明**：此处需补充教师发放`cachelab-handout.tar`文件的具体方式。

首先将`cachelab-handout.tar`复制到你计划用于实验的受保护Linux目录中，然后执行以下命令：

```Plain
linux> tar xvf cachelab-handout.tar
```

该命令会创建一个名为`cachelab-handout`的目录，包含多个文件。你需要修改其中两个文件：`csim.c`和`trans.c`。编译这两个文件的命令如下：

```Plain
linux> make clean
linux> make
```

**警告**：不要用Windows的WinZip程序打开`.tar`文件（许多浏览器会自动执行此操作）。请将文件保存到Linux目录，使用Linux的`tar`命令解压。本课程中，切勿在Linux以外的平台修改文件，否则可能导致数据（及重要工作）丢失！

## 4 实验说明

实验分为两部分：A部分要求实现缓存模拟器，B部分要求编写缓存性能优化的矩阵转置函数。

### 4.1 参考轨迹文件

实验材料目录下的`traces`子目录包含一系列参考轨迹文件，用于验证A部分实现的缓存模拟器的正确性。这些轨迹文件由Linux工具`valgrind`生成。例如，在命令行输入以下命令，可运行可执行程序`ls -l`、捕获其所有内存访问轨迹（按执行顺序）并输出到标准输出：

```Plain
linux> valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l
```

Valgrind生成的内存轨迹格式如下：

```Plain
I 0400d7d4,8
M 0421c7f0,4
L 04f6b868,8
S 7ff0005c8,8
```

每一行表示一次或两次内存访问，格式为：

```
[空格]操作 地址,大小
```

- 操作字段：表示内存访问类型
  - `I`：指令加载（无前置空格）；
  - `L`：数据加载（有前置空格）；
  - `S`：数据存储（有前置空格）；
  - `M`：数据修改（先加载后存储，有前置空格）。
- 地址字段：64位十六进制内存地址；
- 大小字段：访问的字节数。

### 4.2 A部分：编写缓存模拟器

在A部分，你需要在`csim.c`中实现一个缓存模拟器。该模拟器需读取Valgrind内存轨迹，模拟缓存的命中/缺失行为，并输出总命中数、缺失数和驱逐数。

我们提供了一个参考缓存模拟器的二进制可执行文件`csim-ref`，它能模拟任意大小和相联度的缓存在Valgrind轨迹文件上的行为，采用LRU（最近最少使用）替换策略选择要驱逐的缓存行。

#### 参考模拟器的命令行参数

```Plain
用法：./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>
```

- `-h`：可选帮助参数，打印使用说明；
- `-v`：可选详细模式参数，显示轨迹信息；
- `-s <s>`：集合索引位数（集合数`S = 2^s`）；
- `-E <E>`：相联度（每个集合的缓存行数）；
- `-b <b>`：块位数（块大小`B = 2^b`）；
- `-t <tracefile>`：待复现的Valgrind轨迹文件名。

命令行参数基于《CS:APP2e》教材第597页的符号（s、E、b）。示例：

```Plain
linux> ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace
hits:4 misses:5 evictions:3
```

详细模式下的同一示例：

```Plain
linux> ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace
M 20,1 miss hit
L 10,1 miss
L 22,1 hit
S 18,1 hit
L 110,1 miss eviction
L 210,1 miss eviction
M 12,1 miss eviction hit
hits:4 misses:5 evictions:3
```

#### A部分编程规则

1. 在`csim.c`的头部注释中注明你的姓名和登录ID；

2. `csim.c`必须无警告编译才能获得学分；

3. 模拟器需支持任意的s、E和b值，因此需使用`malloc`函数动态分配数据结构（可通过`man malloc`查看该函数用法）；

4. 本实验仅关注数据缓存性能，因此模拟器需忽略所有指令缓存访问（以`I`开头的行）。Valgrind生成的轨迹中，`I`始终在第一列（无前置空格），`M`、`L`、`S`在第二列（有前置空格），可利用这一特征解析轨迹；

5. 为获得A部分学分，需在`main`函数末尾调用`printSummary`函数，传入总命中数、缺失数和驱逐数：

   1. ```C
      printSummary(hit_count, miss_count, eviction_count);
      ```

6. 假设内存访问对齐正确，单个内存访问不会跨越块边界，因此可忽略Valgrind轨迹中的请求大小。

### 4.3 B部分：优化矩阵转置

在B部分，你需要在`trans.c`中编写一个缓存缺失尽可能少的矩阵转置函数。

设矩阵`A`的第i行第j列元素为`A_ij`，其转置矩阵`A^T`满足`A_ij = A^T_ji`。

我们提供了一个示例转置函数（`trans.c`中），可计算`N×M`矩阵`A`的转置并存储到`M×N`矩阵`B`中：

```C
char trans_desc[] = "Simple row-wise scan transpose";
void trans(int M, int N, int A[N][M], int B[M][N])
```

该示例函数正确但效率低下，其访问模式会导致较多缓存缺失。

你的任务是实现一个名为`transpose_submit`的函数，在不同大小的矩阵上最小化缓存缺失次数：

```C
char transpose_submit_desc[] = "Transpose submission";
void transpose_submit(int M, int N, int A[N][M], int B[M][N]);
```

**注意**：请勿修改`transpose_submit`函数的描述字符串（"Transpose submission"），自动评分器会通过该字符串识别待评分的转置函数。

#### B部分编程规则

1. 在`trans.c`的头部注释中注明你的姓名和登录ID；
2. `trans.c`必须无警告编译才能获得学分；
3. 每个转置函数最多定义12个int型局部变量；
4. 禁止通过long型变量或位操作将多个值存储到单个变量中，以规避上述限制；
5. 转置函数不得使用递归；
6. 若使用辅助函数，辅助函数与顶层转置函数的栈上局部变量总数不得超过12个（例如：转置函数定义8个变量，调用的辅助函数定义4个变量，该辅助函数再调用另一个定义2个变量的函数，总变量数为14，违反规则）；
7. 转置函数不得修改数组`A`，但可自由操作数组`B`的内容；
8. 禁止在代码中定义任何数组或使用`malloc`的任何变体。

## 5 评分标准

实验总分60分，具体分布如下：

- A部分：27分；
- B部分：26分；
- 代码风格：7分。

### 5.1 A部分评分

我们将使用不同的缓存参数和轨迹文件测试你的缓存模拟器，共8个测试用例：

```Plain
./csim -s 1 -E 1 -b 1 -t traces/yi2.trace
./csim -s 4 -E 2 -b 4 -t traces/yi.trace
./csim -s 2 -E 1 -b 4 -t traces/dave.trace
./csim -s 2 -E 1 -b 3 -t traces/trans.trace
./csim -s 2 -E 2 -b 3 -t traces/trans.trace
./csim -s 2 -E 4 -b 3 -t traces/trans.trace
./csim -s 5 -E 1 -b 5 -t traces/trans.trace
./csim -s 5 -E 1 -b 5 -t traces/long.trace
```

- 前7个测试用例各3分，最后1个测试用例6分；
- 可使用参考模拟器`csim-ref`获取每个测试用例的正确结果，调试时可通过`-v`选项查看详细的命中/缺失/驱逐记录；
- 每个测试用例的命中数、缺失数、驱逐数各占该用例分数的1/3（例如：3分的用例中，命中数和缺失数正确但驱逐数错误，可得2分）。

### 5.2 B部分评分

我们将评估`transpose_submit`函数在三种不同大小矩阵上的正确性和性能：

- 32×32（M=32，N=32）；
- 64×64（M=64，N=64）；
- 61×67（M=61，N=67）。

#### 5.2.1 性能评分（26分）

对于每种矩阵大小，性能评估方式为：用Valgrind提取函数的地址轨迹，再用参考模拟器在参数为（s=5，E=1，b=5）的缓存上复现该轨迹，根据缺失数`m`评分（线性缩放）：

- 32×32：`m < 300`得8分，`m > 600`得0分；
- 64×64：`m < 1300`得8分，`m > 2000`得0分；
- 61×67：`m < 2000`得10分，`m > 3000`得0分。

**注意**：函数必须正确才能获得对应矩阵大小的性能分；仅需支持上述三种矩阵大小，可针对每种大小单独优化（例如：显式判断输入大小并执行不同优化代码）。

### 5.3 代码风格评分（7分）

由课程工作人员手动评定，评分标准参考课程网站；工作人员会检查B部分代码是否存在非法数组和过多局部变量。

## 6 实验操作指南

### 6.1 A部分操作

我们提供了自动评分程序`test-csim`，用于测试缓存模拟器在参考轨迹上的正确性。运行测试前需先编译模拟器：

```Plain
linux> make
linux> ./test-csim
```

测试输出会显示每个测试用例的得分、缓存参数、输入轨迹文件，以及你的模拟器与参考模拟器的结果对比（示例如下）：

```Plain
你的模拟器        参考模拟器        得分  (s,E,b)        命中数 缺失数 驱逐数  命中数 缺失数 驱逐数
3       (1,1,1)        9      8      6      9      8      6    traces/yi2.trace
3       (2,1,4)        3      4      2      3      4      2    traces/dave.trace
3       (4,2,4)        5      2      1      5      2      1    traces/yi.trace
3       (2,1,3)        201    167    167    201    167    167  traces/trans.trace
3       (2,2,3)        71     37     29     71     37     29    traces/trans.trace
3       (2,4,3)        231    212    26     231    212    26    traces/trans.trace
3       (5,1,5)        7      10     0      7      10     0      traces/trans.trace
6       (5,1,5)        265189 21775  21743  265189 21775  21743  traces/long.trace
总分：27
```

#### A部分提示与建议

1. 初始调试可使用小型轨迹文件（如`traces/dave.trace`）；

2. 参考模拟器的`-v`选项可显示每个内存访问的命中/缺失/驱逐情况，建议在你的`csim.c`中实现该功能，便于与参考模拟器对比调试；

3. 建议使用`getopt`函数解析命令行参数，需包含以下头文件：

   1. ```C
      #include <getopt.h>
      #include <stdlib.h>
      #include <unistd.h>
      ```

   2.  可通过`man 3 getopt`查看该函数详情；

4. 数据加载（L）或存储（S）操作最多导致一次缓存缺失；数据修改（M）操作视为对同一地址的加载+存储，可能导致两次命中、一次缺失+一次命中（含可能的驱逐）；

5. 若需使用15-122课程中的C0风格契约，可包含`contracts.h`（实验材料中已提供）。

### 6.2 B部分操作

我们提供了自动评分程序`test-trans.c`，用于测试所有已注册的转置函数的正确性和性能。

#### 注册转置函数

你可在`trans.c`中注册最多100个转置函数，每个函数格式如下：

```C
/* 头部注释 */
char trans_simple_desc[] = "A simple transpose";
void trans_simple(int M, int N, int A[N][M], int B[M][N]) {
    /* 你的转置代码 */
}
```

在`trans.c`的`registerFunctions`函数中，通过以下形式的调用注册函数，供自动评分器评估：

```C
registerTransFunction(trans_simple, trans_simple_desc);
```

运行时，自动评分器会评估所有注册函数并打印结果。**必须注册****`transpose_submit`****函数**（用于评分）：

```C
registerTransFunction(transpose_submit, transpose_submit_desc);
```

可参考`trans.c`中的默认函数了解具体用法。

#### 运行自动评分器

自动评分器接收矩阵大小作为输入，通过Valgrind生成每个注册函数的轨迹，再用参考模拟器在参数为（s=5，E=1，b=5）的缓存上评估性能。

示例：测试32×32矩阵的转置函数，需重新编译`test-trans`并运行：

```Plain
linux> make
linux> ./test-trans -M 32 -N 32
```

输出示例：

```Plain
步骤1：评估注册的转置函数正确性：
函数0（Transpose submission）：正确性：1
函数1（Simple row-wise scan transpose）：正确性：1
函数2（column-wise scan transpose）：正确性：1
函数3（using a zig-zag access pattern）：正确性：1

步骤2：生成注册转置函数的内存轨迹。

步骤3：评估注册转置函数的性能（s=5，E=1，b=5）
函数0（Transpose submission）：命中数：1766，缺失数：287，驱逐数：255
函数1（Simple row-wise scan transpose）：命中数：870，缺失数：1183，驱逐数：1151
函数2（column-wise scan transpose）：命中数：870，缺失数：1183，驱逐数：1151
函数3（using a zig-zag access pattern）：命中数：1076，缺失数：977，驱逐数：945

正式提交函数（函数0）总结：正确性=1，缺失数=287
```

#### B部分提示与建议

1. `test-trans`程序会将第i个函数的轨迹保存到`trace.fi`文件中（注：Valgrind引入的栈访问已被过滤，因此禁止局部数组和限制局部变量数量）。可通过参考模拟器的详细模式调试：

   1. ```Plain
      linux> ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0
      ```

2. 评估使用的是直接映射缓存，冲突缺失是主要问题（尤其对角线元素），需设计减少冲突缺失的访问模式；

3. 阻塞（Blocking）技术可有效减少缓存缺失，详见：http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf。

### 6.3 完整评估

我们提供了驱动程序`./driver.py`，可对模拟器和转置函数进行完整评估（与课程工作人员使用的评估工具一致）。该程序会调用`test-csim`测试模拟器，调用`test-trans`测试三种矩阵大小的转置函数，最终输出得分总结。运行命令：

```Plain
linux> ./driver.py
```

## 7 提交要求

在`cachelab-handout`目录中执行`make`命令时，Makefile会生成一个名为`userid-handin.tar`的压缩包，包含当前的`csim.c`和`trans.c`文件。

**学校特定说明**：此处需补充学生提交`userid-handin.tar`文件的具体方式。

**重要提示**：不要在Windows或Mac机器上创建提交用的压缩包，不要使用`.zip`、`.gzip`或`.tgz`等其他压缩格式。